<!DOCTYPE html>

<html lang="en">
  <head><script src="https://wmc-ahif-2021.github.io/VisualNovel/aboutUs.be1f3b93.js"></script><script src="https://wmc-ahif-2021.github.io/VisualNovel/aboutUs.05d33ae0.js"></script>
    <meta charset="UTF-8">
    <link href="https://wmc-ahif-2021.github.io/VisualNovel/index.c00d1c1e.css" rel="stylesheet" type="text/css">
    <link href="https://wmc-ahif-2021.github.io/VisualNovel/VisualNovel-history.043b9601.css" rel="stylesheet" type="text/css">
    <title>History of visual novels</title>
    <link rel="icon" href="https://wmc-ahif-2021.github.io/VisualNovel/logo.7a8c1cb1.png" type="image/icon type">
  </head>
  <body>

<div id="disclaimer-banner" style="background-color: #fff; justify-content: center; display: flex">
    <p style="margin: 0; padding: .5rem; font-style: italic">
      Educational, non-profit project created by students
    </p>
    <a href="https://www.htl-leonding.at/" style="padding: .5rem 0; font-style: italic">
      @ HTL Leonding.
    </a>
</div>


    <div id="loadingscreen">
      <div class="loader">Loading</div>
    </div>
    <div id="main-content">
      <div class="centered-menu">
        <ul class="navigationBar">
          <li><a href="https://wmc-ahif-2021.github.io/VisualNovel/index.html">Home</a></li>
          <li><a href="https://wmc-ahif-2021.github.io/VisualNovel/character-description.html">Characters</a></li>
          <li><a href="https://wmc-ahif-2021.github.io/VisualNovel/story-description.html">Story</a></li>
          <li><a href="https://wmc-ahif-2021.github.io/VisualNovel/VisualNovel-history.html">History</a></li>
          <li><a href="https://wmc-ahif-2021.github.io/VisualNovel/game.html">Game</a></li>
          <li><a href="https://wmc-ahif-2021.github.io/VisualNovel/aboutUs.html">About us</a></li>
        </ul>
      </div>

      <div class="whiteBox">
        <article class="margin">
          <br>
          <!-- White box ab stand zu text -->
          <h1 class="othersTitle">Visual Novel-history</h1>
          <section>
            <h2>Meaning of "Visual Novel"</h2>
            <p>
              Visual novels are games which often get described as 'interactive
              books'. The player can decide between different decisions which
              all lead to different endings of the game. They mostly get played
              in Japan, which is also the origin of these games. 70% of the PC
              games released in Japan in 2006, are visual novels. In Japan,
              there is a difference made between the novel-part and the
              adventure-part in the visual novel. The novel-part consists mostly
              of the story and very few interactive parts. On the other hand,
              the adventure-part has more of the problem-solving and active
              gameplay.
            </p>
          </section>
          <div>
            <h2>Visuals and Manga influence</h2>
            <p>
              The games were basically a string of puzzels for the player to
              slove. The player had to pick up certain objects, Otherwise they
              wouldn't be able to handle the challenges they encounter later in
              the game. This design shows up throughout Portopia, where the
              player analyzes a crime scene for clues that will advance the
              narrative.
            </p>
            <img src="https://wmc-ahif-2021.github.io/VisualNovel/portopia01.45e8b71b.png" alt="piture of the game portopia" class="VNPictures">
            <img src="https://wmc-ahif-2021.github.io/VisualNovel/portopia02.cb387d6b.png" alt="piture of the game portopia" class="VNPictures">
            <p>
              While visual novels would slowly fade out puzzle-oriented design
              in favor of narrative, all of their other structures remained
              intact, including their visuals. Early visual novels had a more
              manga like style, each panel was composed as a whole, its angles
              and shapes and other visual elements coming together to create a
              very specific scene or convey a particular mood.
            </p>
            <p>
              So when we look at early visual novels, we see them employing the
              same kinds of panel transitions that comics and manga had been
              comfortable using for years. Panel transitions aren't the only
              strategy early visual novels borrow from manga. Subjective motion
              lines show up in Dennou Tenshi at the bottom, and both manga and
              visual novels represent movement in similar ways, albeit for
              different reasons. Yet out of all the techniques early visual
              novels borrowed from manga, panel transitions have proven the most
              useful.
            </p>
            <p>
              The biggest change to Visual Novels came with Tokimeki's visuals.
              In the game the player can take any girl from it, to any location
              in the game. The old strategy of composing shots for specific
              scenes just wasn't feasible for this kind of game. So unable to
              create distinct images for every situation the player could
              encounter, Konami instead decided to compile generic assets that
              could be swapped out depending on the situation.
            </p>
            <img src="https://wmc-ahif-2021.github.io/VisualNovel/tokimeki01.fe09d99e.png" alt="piture of the game tokimeki" class="VNPictures">
            <img src="https://wmc-ahif-2021.github.io/VisualNovel/tokimeki02.e1c62e1f.png" alt="piture of the game tokimeki" class="VNPictures">
            <p>
              Where previous visual novels could only muster a few different
              expressions per shot, Tokimeki's sprites allowed Konami to create
              as many as six expressions per character . Many writers have
              compared this to watching anime or reading manga. The trade-off
              from this arrangement is that while visual novels can no longer
              frame a scene to create a specific effect, they encourage the
              player to approach the narrative in a way early visual novels
              didn't.
            </p>
            <p>
              It's because things are only suggested that the player has the
              space they need to put the story together as they see fit. Far
              from watching a narrative passively unfold before them, the player
              becomes an active participant in it, filling in the gaps that
              either the story or the visuals leave blank. It's up to the player
              to use the combined text and visuals to interpret what they're
              seeing. This isn't to say that later visual novels haven't
              experimented with their form.
            </p>
            <p>
              Indeed, some visual novels really do feel like watching an anime
              or reading a novel. Yet both within individual games and in the
              genre at large, manga shots are the exception, not the rule.
              Theatrics remain the dominant mode of communication for the modern
              visual novel.
            </p>
          </div>
          <br>
        </article>
      </div>
    </div>
    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"6aWTL":[function(require,module,exports) {
var _loadingscreen = require("./scripts/loadingscreen");

},{"./scripts/loadingscreen":"fbjxd"}]},["6aWTL"], "6aWTL", "parcelRequire2321")

</script>
  </body>
</html>
